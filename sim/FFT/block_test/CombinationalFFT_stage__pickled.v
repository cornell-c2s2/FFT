//-------------------------------------------------------------------------
// CombinationalFFT_stage.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL VerilogPlaceholder FFTStageTestHarnessVRTL Definition
// Full name: FFTStageTestHarnessVRTL__BIT_WIDTH_32__DECIMAL_PT_16__N_SAMPLES_4__STAGE_FFT_1
// At /home/ss2723/c2s2/FFT/sim/FFT/FFTStageTestHarnessRTL.py

//***********************************************************
// Pickled source file of placeholder FFTStageTestHarnessVRTL__c0423b316f90c825
//***********************************************************

//-----------------------------------------------------------
// Dependency of placeholder FFTStageTestHarnessVRTL
//-----------------------------------------------------------

`ifndef FFTSTAGETESTHARNESSVRTL
`define FFTSTAGETESTHARNESSVRTL

// The source code below are included because they are specified
// as the v_libs Verilog placeholder option of component FFTStageTestHarnessVRTL__c0423b316f90c825.

// If you get a duplicated def error from files included below, please
// make sure they are included either through the v_libs option or the
// explicit `include statement in the Verilog source code -- if they
// appear in both then they will be included twice!


// End of all v_libs files for component FFTStageTestHarnessVRTL__c0423b316f90c825

`line 1 "FFTStageTestHarnessVRTL.v" 0
`line 1 "FFT-Twiddle_Generator/sim/FFTTwiddleGenerator/SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_16VRTL.v" 0
//SINE WAVE OF BIT_WIDTH = 32, DECIMAL_PT =  16
//FOR FFT OF SIZE = 16
module SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_16VRTL
   (
       output logic [32 - 1:0] sine_wave_out [0:16 - 1]
   );
   assign sine_wave_out[0] = 0;
   assign sine_wave_out[1] = 25079;
   assign sine_wave_out[2] = 46340;
   assign sine_wave_out[3] = 60547;
   assign sine_wave_out[4] = 65536;
   assign sine_wave_out[5] = 60547;
   assign sine_wave_out[6] = 46340;
   assign sine_wave_out[7] = 25079;
   assign sine_wave_out[8] = 0;
   assign sine_wave_out[9] = -25079;
   assign sine_wave_out[10] = -46340;
   assign sine_wave_out[11] = -60547;
   assign sine_wave_out[12] = -65536;
   assign sine_wave_out[13] = -60547;
   assign sine_wave_out[14] = -46340;
   assign sine_wave_out[15] = -25079;
endmodule
`line 2 "FFTStageTestHarnessVRTL.v" 0
`line 1 "FFT-Twiddle_Generator/sim/FFTTwiddleGenerator/SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_8VRTL.v" 0
//SINE WAVE OF BIT_WIDTH = 32, DECIMAL_PT =  16
//FOR FFT OF SIZE = 8
module SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_8VRTL
   (
       output logic [32 - 1:0] sine_wave_out [0:8 - 1]
   );
   assign sine_wave_out[0] = 0;
   assign sine_wave_out[1] = 46340;
   assign sine_wave_out[2] = 65536;
   assign sine_wave_out[3] = 46340;
   assign sine_wave_out[4] = 0;
   assign sine_wave_out[5] = -46340;
   assign sine_wave_out[6] = -65536;
   assign sine_wave_out[7] = -46340;
endmodule
`line 3 "FFTStageTestHarnessVRTL.v" 0
`line 1 "FFT-Twiddle_Generator/sim/FFTTwiddleGenerator/SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_2VRTL.v" 0
//SINE WAVE OF BIT_WIDTH = 32, DECIMAL_PT =  16
//FOR FFT OF SIZE = 2
module SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_2VRTL
   (
       output logic [32 - 1:0] sine_wave_out [0:2 - 1]
   );
   assign sine_wave_out[0] = 0;
   assign sine_wave_out[1] = 0;
endmodule
`line 4 "FFTStageTestHarnessVRTL.v" 0
`line 1 "FFT-Twiddle_Generator/sim/FFTTwiddleGenerator/SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_4VRTL.v" 0
//SINE WAVE OF BIT_WIDTH = 32, DECIMAL_PT =  16
//FOR FFT OF SIZE = 4
module SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_4VRTL
   (
       output logic [32 - 1:0] sine_wave_out [0:4 - 1]
   );
   assign sine_wave_out[0] = 0;
   assign sine_wave_out[1] = 65536;
   assign sine_wave_out[2] = 0;
   assign sine_wave_out[3] = -65536;
endmodule
`line 5 "FFTStageTestHarnessVRTL.v" 0
`line 1 "./FFT_StageVRTL.v" 0
`line 1 "FFT-Twiddle_Generator/sim/FFTTwiddleGenerator/TwiddleGeneratorVRTL.v" 0
`ifndef TWIDDLE_GENERATOR
`define TWIDDLE_GENERATOR
module TwiddleGeneratorVRTL 
   #(
        BIT_WIDTH     = 4,
        DECIMAL_PT    = 2,
        SIZE_FFT      = 8,
        STAGE_FFT     = 0 
    )
    (
        input logic  [BIT_WIDTH - 1:0] sine_wave_in     [0:SIZE_FFT - 1], //sine_wave_in = sin(2*pi m / N)
        
        output logic [BIT_WIDTH - 1:0] twiddle_real     [SIZE_FFT/2 - 1:0],
        output logic [BIT_WIDTH - 1:0] twiddle_imaginary[SIZE_FFT/2 - 1:0]
    );

    int trace;
    assign trace =  ( 0 * ( SIZE_FFT / ( 2* (2**STAGE_FFT) ) ) ) % SIZE_FFT;
    int trace2;
    assign trace2 = ( 1 * ( SIZE_FFT / ( 2* (2**STAGE_FFT) ) ) ) % SIZE_FFT;
    int trace3;
    assign trace3 = ( 2 * ( SIZE_FFT / ( 2* (2**STAGE_FFT) ) ) ) % SIZE_FFT;
    int trace4;
    assign trace4 = ( 3 * ( SIZE_FFT / ( 2* (2**STAGE_FFT) ) ) ) % SIZE_FFT;
    generate
        genvar m;
        for(m = 0; m < 2 ** STAGE_FFT; m = m + 1) begin
            genvar i;
            for(i = 0; i < SIZE_FFT; i = i + 2 ** (STAGE_FFT + 1) ) begin
                if(m != 0) begin
                    assign twiddle_real     [i/2 + m] =  sine_wave_in[(  ( m * ( SIZE_FFT / ( 2 * (2**STAGE_FFT) ) ) ) % SIZE_FFT ) + SIZE_FFT/4];
                    assign twiddle_imaginary[i/2 + m] =  sine_wave_in[(  ( m * ( SIZE_FFT / ( 2 * (2**STAGE_FFT) ) ) ) % SIZE_FFT )              ];
                end else begin
                    assign twiddle_real     [i/2 + m] = 1 << DECIMAL_PT;
                    assign twiddle_imaginary[i/2 + m] = 0;
                end
            end
        end
    endgenerate

endmodule

`endif
`line 2 "./FFT_StageVRTL.v" 0
`line 1 "FFT-Crossbar/sim/CombinationalFFTCrossbar/CombinationalFFTCrossbarVRTL.v" 0
`ifndef COMBINATIONAL_FFT_CROSSBAR
`define COMBINATIONAL_FFT_CROSSBAR

module CombinationalFFTCrossbarVRTl
   #(
        BIT_WIDTH  = 32,
        SIZE_FFT   = 8 ,
        STAGE_FFT  = 0 ,
        FRONT      = 1 
    )
    (
        input  logic  [BIT_WIDTH - 1:0] recv_real      [SIZE_FFT - 1:0],
        input  logic  [BIT_WIDTH - 1:0] recv_imaginary [SIZE_FFT - 1:0],
        input  logic                    recv_val       [SIZE_FFT - 1:0],
        output logic                    recv_rdy       [SIZE_FFT - 1:0],

        output logic [BIT_WIDTH - 1:0] send_real       [SIZE_FFT - 1:0],
        output logic [BIT_WIDTH - 1:0] send_imaginary  [SIZE_FFT - 1:0],
        output logic                   send_val        [SIZE_FFT - 1:0],
        input  logic                   send_rdy        [SIZE_FFT - 1:0]
    );
    generate
        genvar m;
        for( m = 0; m < 2 ** STAGE_FFT; m = m + 1 ) begin
            genvar i;
            for(i = m; i < SIZE_FFT; i = i + 2 ** ( STAGE_FFT + 1 ) ) begin
                    if(FRONT == 1) begin  
                        assign send_real     [i + m] = recv_real     [i];
                        assign send_imaginary[i + m] = recv_imaginary[i];
                        assign send_val      [i + m] = recv_val      [i];
                        assign recv_rdy      [i + m] = send_rdy      [i];

                        assign send_real     [i + m + 1] = recv_real     [i + 2**STAGE_FFT];
                        assign send_imaginary[i + m + 1] = recv_imaginary[i + 2**STAGE_FFT];
                        assign send_val      [i + m + 1] = recv_val      [i + 2**STAGE_FFT];
                        assign recv_rdy      [i + m + 1] = send_rdy      [i + 2**STAGE_FFT];
                    end else begin  
                        assign send_real     [i] = recv_real     [i + m];
                        assign send_imaginary[i] = recv_imaginary[i + m];
                        assign send_val      [i] = recv_val      [i + m];
                        assign recv_rdy      [i] = send_rdy      [i + m];

                        assign send_real     [i + 2**STAGE_FFT] = recv_real     [i + m + 1];
                        assign send_imaginary[i + 2**STAGE_FFT] = recv_imaginary[i + m + 1];
                        assign send_val      [i + 2**STAGE_FFT] = recv_val      [i + m + 1];
                        assign recv_rdy      [i + 2**STAGE_FFT] = send_rdy      [i + m + 1];
                    end
            end
        end
    endgenerate

endmodule

`endif
`line 3 "./FFT_StageVRTL.v" 0
`line 1 "../../../butterfly-unit/sim/butterfly/ButterflyVRTL.v" 0
`ifndef PROJECT_BUTTERFLY_V
`define PROJECT_BUTTERFLY_V
`line 1 "../../../fixedpt-iterative-complex-multiplier/sim/cmultiplier/FpcmultVRTL.v" 0
`ifndef FIXED_POINT_ITERATIVE_COMPLEX_MULTIPLIER
`define FIXED_POINT_ITERATIVE_COMPLEX_MULTIPLIER
`line 1 "../../../fixedpt-iterative-multiplier/sim/multiplier/FpmultVRTL.v" 0
`ifndef FIXED_POINT_ITERATIVE_MULTIPLIER
`define FIXED_POINT_ITERATIVE_MULTIPLIER

`line 1 "../../../fixedpt-iterative-multiplier/sim/multiplier/muxes.v" 0
//========================================================================
// Verilog Components: Muxes
//========================================================================

`ifndef VC_MUXES_V
`define VC_MUXES_V

//------------------------------------------------------------------------
// 2 Input Mux
//------------------------------------------------------------------------

module vc_Mux2
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1,
  input  logic               sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      1'd0 : out = in0;
      1'd1 : out = in1;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 3 Input Mux
//------------------------------------------------------------------------

module vc_Mux3
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2,
  input  logic         [1:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      2'd0 : out = in0;
      2'd1 : out = in1;
      2'd2 : out = in2;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 4 Input Mux
//------------------------------------------------------------------------

module vc_Mux4
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3,
  input  logic         [1:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      2'd0 : out = in0;
      2'd1 : out = in1;
      2'd2 : out = in2;
      2'd3 : out = in3;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 5 Input Mux
//------------------------------------------------------------------------

module vc_Mux5
#(
 parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 6 Input Mux
//------------------------------------------------------------------------

module vc_Mux6
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4, in5,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      3'd5 : out = in5;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 7 Input Mux
//------------------------------------------------------------------------

module vc_Mux7
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4, in5, in6,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      3'd5 : out = in5;
      3'd6 : out = in6;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 8 Input Mux
//------------------------------------------------------------------------

module vc_Mux8
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4, in5, in6, in7,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      3'd5 : out = in5;
      3'd6 : out = in6;
      3'd7 : out = in7;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// N Input Mux
//------------------------------------------------------------------------

module vc_MuxN
#(
  parameter p_nbits = 1,
  parameter p_ninputs = 2
)(
  input  logic [p_ninputs-1:0][p_nbits-1:0] in,
  input  logic [$clog2(p_ninputs)-1:0]      sel,
  output logic [p_nbits-1:0]                out
);

  assign out = in[sel];

endmodule

`endif /* VC_MUXES_V */


`line 5 "../../../fixedpt-iterative-multiplier/sim/multiplier/FpmultVRTL.v" 0
`line 1 "../../../fixedpt-iterative-multiplier/sim/multiplier/RegisterV_Reset.v" 0
`ifndef PROJECT_REGISTER_V_RESET
`define PROJECT_REGISTER_V_RESET

module RegisterV_Reset
	#(parameter N = 8)
	(clk, reset, w, d, q);
    input logic clk;
    input logic reset;
    input  logic w;
    input logic [N-1:0] d;
    output logic [N-1:0] q;
    logic [N-1:0] regout;

    assign q = regout;

    always @(posedge clk) begin
	if (reset)
	    regout <= 0;
	else if (w)
	    regout <= d;
    end
endmodule

`endif

`line 6 "../../../fixedpt-iterative-multiplier/sim/multiplier/FpmultVRTL.v" 0

module FpmultVRTL
# (
	parameter n = 32, // bit width
	parameter d = 16, // number of decimal bits
	parameter sign = 1 // 1 if signed, 0 otherwise.
) (clk, reset, recv_val, recv_rdy, send_val, send_rdy, a, b, c);
	// performs the operation c = a*b
	// Equivalent to taking the integer representations of both numbers,
	// multiplying, and then shifting right
	input logic clk, reset;
	input logic recv_val, send_rdy;
	input logic [n-1:0] a, b;
	output logic [n-1:0] c;
	output logic send_val, recv_rdy;

	logic do_carry, do_add, in_wait;

	fpmult_control #(n, d) control (
		.clk(clk),
		.reset(reset),
		.recv_val(recv_val),
		.recv_rdy(recv_rdy),
		.send_val(send_val),
		.send_rdy(send_rdy),
		.in_wait(in_wait),
		.do_add(do_add),
		.do_carry(do_carry)
	);

	fpmult_datapath #(n, d) datapath (
		.clk(clk),
		.reset(reset),
		.in_wait(in_wait),
		.do_add(do_add),
		.do_carry((sign != 0) & do_carry),
		.a({ {d{(sign != 0) & a[n-1]}}, a }),
		.b(b),
		.c(c)
	);

endmodule

module fpmult_control
# (
	parameter n, parameter d
) (
	input logic clk,
	input logic reset,
	input logic recv_val,
	output logic recv_rdy,
	output logic send_val,
	input logic send_rdy,
	output logic in_wait,
	output logic do_add,
	output logic do_carry
);

	localparam [1:0]
		IDLE = 2'd0,
		CALC = 2'd1,
		DONE = 2'd2;

	logic [1:0] state, next_state;
	logic [$clog2(n)-1:0] counter;
	logic counter_reset;
	
	// manage state
	always @(*) begin
		case (state)
			IDLE: begin
				if (recv_val) next_state = CALC;
				else next_state = IDLE;
			end
			CALC: begin
				if (counter == ($clog2(n))'(n-1)) next_state = DONE;
				else next_state = CALC;
			end
			DONE: begin
				if (send_rdy) next_state = IDLE;
				else next_state = DONE;
			end
			default: begin
				next_state = IDLE;
			end
		endcase
	end

	// manage datapath
	always @(*) begin
		case (state)
			IDLE: begin
				in_wait = 1; do_add = 0; do_carry = 0; counter_reset = 0;
				recv_rdy = 1; send_val = 0;
			end
			CALC: begin
				in_wait = 0; do_add = 1; do_carry = (counter == ($clog2(n))'(n-1)); counter_reset = 0;
				recv_rdy = 0; send_val = 0;
			end
			DONE: begin
				in_wait = 0; do_add = 0; do_carry = 0; counter_reset = 1;
				recv_rdy = 0; send_val = 1;
			end
			default: begin
			end
		endcase
	end

	// reset logic
	always @(posedge clk) begin
		if (reset) begin
			state <= IDLE;
		end else begin
			state <= next_state;
		end
	end

	// counter logic
	always @(posedge clk) begin
		if (reset || counter_reset) begin
			counter <= 0;
		end else if (state == CALC) begin
			counter <= counter + 1;
		end else begin
			counter <= counter;
		end
	end
	
endmodule

module fpmult_datapath
# (
	parameter n, parameter d
) (
	input logic clk,
	input logic reset,
	input logic in_wait, // waiting for input
	input logic do_add,
	input logic do_carry,
	input logic [n+d-1:0] a,
	input logic [n-1:0] b,
	output logic [n-1:0] c
);

	logic [(n+d)-1:0] acc_in;
	logic [(n+d)-1:0] acc_out;
	
	RegisterV_Reset #(n+d) acc_reg (
		.clk(clk),
		.reset(in_wait | reset),
		.w(1),
		.d(acc_in),
		.q(acc_out)
	);

	logic [(n+d)-1:0] a_const_out;

	RegisterV_Reset #(n+d) a_const_reg (
		.clk(clk),
		.reset(reset),
		.w(in_wait),
		.d(a),
		.q(a_const_out)
	);

	logic [(n+d)-1:0] a_in;
	logic [(n+d)-1:0] a_out;

	RegisterV_Reset #(n+d) a_reg (
		.clk(clk),
		.reset(reset),
		.w(1),
		.d(a_in),
		.q(a_out)
	);

	logic [(n+d)-1:0] b_in;
	logic [(n+d)-1:0] b_out;

	RegisterV_Reset #(n) b_reg (
		.clk(clk),
		.reset(reset),
		.w(1),
		.d(b_in),
		.q(b_out)
	);

	vc_Mux2 #(n+d) a_sel (
		.in0(a_out << 1),
		.in1(a),
		.sel(in_wait),
		.out(a_in)
	);

	vc_Mux2 #(n) b_sel (
		.in0(b_out >> 1),
		.in1(b),
		.sel(in_wait),
		.out(b_in)
	);

	logic [n+d-1:0] add_tmp;
	logic [n+d-1:0] carry;

	logic [2*n-1:0] carry_tmp, carry_tmp2;
	assign carry_tmp = { {(n-d){a_const_out[n+d-1]}}, a_const_out}; // sign extend a
	assign carry_tmp2 = ((carry_tmp << n) - carry_tmp) << (n-1);

	vc_Mux2 #(n+d) carry_sel (
		.in0(a_out),
		.in1(carry_tmp2[n+d-1:0]),
		.sel(do_carry),
		.out(add_tmp)
	);

	vc_Mux2 #(n+d) add_sel (
		.in0(acc_out),
		.in1(acc_out + add_tmp),
		.sel(do_add & b_out[0]),
		.out(acc_in)
	);

	assign c = acc_out[n+d-1:d];
endmodule

`endif

`line 4 "../../../fixedpt-iterative-complex-multiplier/sim/cmultiplier/FpcmultVRTL.v" 0
`line 1 "../../../C2S2-Module-Library/lib/sim/nbitregister/RegisterV_Reset.v" 0
`ifndef PROJECT_REGISTER_V_RESET
`define PROJECT_REGISTER_V_RESET

module RegisterV_Reset
	#(parameter N = 8)
	(clk, reset, w, d, q);
    input logic clk;
    input logic reset;
    input  logic w;
    input logic [N-1:0] d;
    output logic [N-1:0] q;
    logic [N-1:0] regout;

    assign q = regout;

    always @(posedge clk) begin
	if (reset)
	    regout <= 0;
	else if (w)
	    regout <= d;
    end
endmodule

`endif

`line 5 "../../../fixedpt-iterative-complex-multiplier/sim/cmultiplier/FpcmultVRTL.v" 0
`line 1 "muxes.v" 0
//========================================================================
// Verilog Components: Muxes
//========================================================================

`ifndef VC_MUXES_V
`define VC_MUXES_V

//------------------------------------------------------------------------
// 2 Input Mux
//------------------------------------------------------------------------

module vc_Mux2
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1,
  input  logic               sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      1'd0 : out = in0;
      1'd1 : out = in1;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 3 Input Mux
//------------------------------------------------------------------------

module vc_Mux3
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2,
  input  logic         [1:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      2'd0 : out = in0;
      2'd1 : out = in1;
      2'd2 : out = in2;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 4 Input Mux
//------------------------------------------------------------------------

module vc_Mux4
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3,
  input  logic         [1:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      2'd0 : out = in0;
      2'd1 : out = in1;
      2'd2 : out = in2;
      2'd3 : out = in3;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 5 Input Mux
//------------------------------------------------------------------------

module vc_Mux5
#(
 parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 6 Input Mux
//------------------------------------------------------------------------

module vc_Mux6
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4, in5,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      3'd5 : out = in5;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 7 Input Mux
//------------------------------------------------------------------------

module vc_Mux7
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4, in5, in6,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      3'd5 : out = in5;
      3'd6 : out = in6;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 8 Input Mux
//------------------------------------------------------------------------

module vc_Mux8
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4, in5, in6, in7,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      3'd5 : out = in5;
      3'd6 : out = in6;
      3'd7 : out = in7;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// N Input Mux
//------------------------------------------------------------------------

module vc_MuxN
#(
  parameter p_nbits = 1,
  parameter p_ninputs = 2
)(
  input  logic [p_ninputs-1:0][p_nbits-1:0] in,
  input  logic [$clog2(p_ninputs)-1:0]      sel,
  output logic [p_nbits-1:0]                out
);

  assign out = in[sel];

endmodule

`endif /* VC_MUXES_V */


`line 6 "../../../fixedpt-iterative-complex-multiplier/sim/cmultiplier/FpcmultVRTL.v" 0

module FpcmultVRTL
# (
	parameter n = 32, // bit width
	parameter d = 16 // number of decimal bits
) (
	input logic clk,
	input logic reset,
	input logic recv_val,
	output logic recv_rdy,
	output logic send_val,
	input logic send_rdy,
	input logic [n-1:0] ar,
	input logic [n-1:0] ac,
	input logic [n-1:0] br,
	input logic [n-1:0] bc,
	output logic [n-1:0] cr,
	output logic [n-1:0] cc
);
	// performs c = a * b on complex a and b

	// cr = (ar * br) - (ac * bc)
	// cc = (ar * bc) + (br * ac) = (ar + ac)(br + bc) - (ac * bc) - (ar * br)

	logic mul_recv_rdy, mul_send_val, in_wait;
	logic [1:0] mul_stage;

	fpcmult_control #(n, d) control (
		.clk(clk),
		.reset(reset),
		.recv_val(recv_val),
		.recv_rdy(recv_rdy),
		.send_val(send_val),
		.send_rdy(send_rdy),
		.mul_recv_rdy(mul_recv_rdy),
		.mul_send_val(mul_send_val),
		.in_wait(in_wait),
		.mul_stage(mul_stage)
	);

	fpcmult_datapath #(n, d) datapath (
		.clk(clk),
		.reset(reset),
		.ar(ar),
		.ac(ac),
		.br(br),
		.bc(bc),
		.cr(cr),
		.cc(cc),
		.mul_recv_rdy(mul_recv_rdy),
		.mul_send_val(mul_send_val),
		.in_wait(in_wait),
		.mul_stage(mul_stage)
	);
endmodule

module fpcmult_control
# (
	parameter n, parameter d
) (
	input logic clk,
	input logic reset,
	input logic recv_val,
	output logic recv_rdy,
	output logic send_val,
	input logic send_rdy,
	input logic mul_recv_rdy,
	input logic mul_send_val,
	output logic [1:0] mul_stage,
	output logic in_wait
);

	localparam [2:0]
		IDLE = 3'd0,
		DONE = 3'd1,
		ARBR = 3'd2,
		ACBC = 3'd3,
		AABB = 3'd4,
		STALL = 3'd5;

	logic [2:0] state, next_state, post_idle;
	
	always @(*) begin
		case (state)
			IDLE: begin
				if (recv_val) next_state = AABB;
				else begin
					next_state = IDLE;
					post_idle = AABB;
				end
			end
			ARBR: begin
				if (mul_send_val) begin
					next_state = ACBC;
					post_idle = ACBC;
				end else begin
					next_state = ARBR;
				end
			end
			ACBC: begin
				if (mul_send_val) next_state = DONE;
				else next_state = ACBC;
			end
			AABB: begin
				if (mul_send_val) begin
					next_state = ARBR;
					post_idle = ARBR;
				end else next_state = AABB;
			end
			DONE: begin
				if (send_rdy) next_state = IDLE;
				else next_state = DONE;
			end
			STALL: begin
				if (mul_recv_rdy) next_state = post_idle;
				else next_state = STALL;
			end
			default: begin
				next_state = IDLE;
			end
		endcase
	end

	always @(*) begin
		case (state)
			IDLE: begin
				in_wait = 1; mul_stage = 3;
				recv_rdy = 1; send_val = 0;
			end
			AABB: begin
				in_wait = 0; mul_stage = 0;
				recv_rdy = 0; send_val = 0;
			end
			ARBR: begin
				in_wait = 0; mul_stage = 1;
				recv_rdy = 0; send_val = 0;
			end
			ACBC: begin
				in_wait = 0; mul_stage = 2;
				recv_rdy = 0; send_val = 0;
			end
			DONE: begin
				in_wait = 0; mul_stage = 3;
				recv_rdy = 0; send_val = 1;
			end
			default: begin
				in_wait = 0; mul_stage = 3;
				recv_rdy = 0; send_val = 0;
			end
		endcase
	end

	always @(posedge clk) begin
		if (reset) begin
			state <= IDLE;
		end else begin
			state <= next_state;
		end
	end
endmodule


module fpcmult_datapath
# (
	parameter n, parameter d
) (
	input logic clk,
	input logic reset,
	input logic [n-1:0] ar,
	input logic [n-1:0] ac,
	input logic [n-1:0] br,
	input logic [n-1:0] bc,
	output logic [n-1:0] cr,
	output logic [n-1:0] cc,
	input logic in_wait,
	input logic[1:0] mul_stage,
	output logic mul_recv_rdy,
	output logic mul_send_val
);

	logic [n-1:0] c_ar, c_ac, c_br, c_bc, c_arac;
	logic [n-1:0] i_ar, i_ac, i_arac;
	logic [n-1:0] mul_a, mul_b, mul_c;

	assign cr = c_ar - c_ac;
	assign cc = c_arac - c_ar - c_ac;

	RegisterV_Reset #(n) reg_c_ar (
		.clk(clk),
		.reset(reset),
		.w(in_wait || mul_stage == 1),
		.d(i_ar),
		.q(c_ar)
	);

	RegisterV_Reset #(n) reg_c_br (
		.clk(clk),
		.reset(reset),
		.w(in_wait),
		.d(br),
		.q(c_br)
	);

	RegisterV_Reset #(n) reg_c_ac (
		.clk(clk),
		.reset(reset),
		.w(in_wait || mul_stage == 2),
		.d(i_ac),
		.q(c_ac)
	);

	RegisterV_Reset #(n) reg_c_bc (
		.clk(clk),
		.reset(reset),
		.w(in_wait),
		.d(bc),
		.q(c_bc)
	);

	RegisterV_Reset #(n) reg_c_arac (
		.clk(clk),
		.reset(reset),
		.w(mul_stage == 0),
		.d(mul_c),
		.q(c_arac)
	);

	FpmultVRTL #(n, d, 1) multiplier (
		.clk(clk),
		.reset(reset),
		.a(mul_a),
		.b(mul_b),
		.c(mul_c),
		.recv_val(mul_stage != 3),
		.recv_rdy(mul_recv_rdy),
		.send_val(mul_send_val),
		.send_rdy(1)
	);

	// Used to select between storing arbr multiplication output and input
	vc_Mux2 #(n) iomul_ar_sel (
		.in0(ar),
		.in1(mul_c),
		.sel(~in_wait),
		.out(i_ar)
	);

	vc_Mux2 #(n) iomul_ac_sel (
		.in0(ac),
		.in1(mul_c),
		.sel(~in_wait),
		.out(i_ac)
	);

	vc_Mux3 #(n) mul_a_sel (
		.in0(c_ar + c_ac),
		.in1(c_ar),
		.in2(c_ac),
		.sel(mul_stage),
		.out(mul_a)
	);

	vc_Mux3 #(n) mul_b_sel (
		.in0(c_br + c_bc),
		.in1(c_br),
		.in2(c_bc),
		.sel(mul_stage),
		.out(mul_b)
	);
endmodule
`endif

`line 4 "../../../butterfly-unit/sim/butterfly/ButterflyVRTL.v" 0
`line 1 "../../../butterfly-unit/sim/butterfly/RegisterV.v" 0
`ifndef REGISTER_V
`define REGISTER_V

module RegisterV
	#(parameter BIT_WIDTH = 32)
	(clk, reset, w, d, q);

	input logic clk;
	input logic reset;
	input  logic w;
	input logic [BIT_WIDTH-1:0] d;
	output logic [BIT_WIDTH-1:0] q;
	logic [BIT_WIDTH-1:0] regout;

	assign q = regout;

	always @(posedge clk) begin
		if (w)
			regout <= d;
	end
endmodule

`endif

`line 5 "../../../butterfly-unit/sim/butterfly/ButterflyVRTL.v" 0
module ButterflyVRTL
#(
	parameter n = 32,
	parameter d = 16,
	parameter mult = 0
	// Optimization parameter to save area:
	// 0 if we include the multiplier
	// 1 if omega = 1
	// 2 if omega = -1
	// 3 if omega = i (j)
	// 3 if omega = -i (-j)
) (clk, reset, recv_val, recv_rdy, send_val, send_rdy, ar, ac, br, bc, wr, wc, cr, cc, dr, dc);
	/* performs the butterfly operation, equivalent to doing
		| 1  w |   | a |   | c |
		| 1 -w | * | b | = | d |
	*/

	input logic clk, reset;
	input logic recv_val, send_rdy;
	input logic [n-1:0] ar, ac, br, bc, wr, wc;
	output logic send_val, recv_rdy;
	output logic [n-1:0] cr, cc, dr, dc;

	logic [n-1:0] ar_imm, ac_imm;

	logic [n-1:0] tr, tc;

	FpcmultVRTL #(.n(n), .d(d)) mul ( // ar * br
        .clk(clk),
        .reset(reset),
        .ar(br),
        .ac(bc),
        .br(wr),
        .bc(wc),
        .cr(tr),
        .cc(tc),
        .recv_val(recv_val),
        .recv_rdy(recv_rdy),
        .send_val(send_val),
        .send_rdy(send_rdy)
            );
	
	RegisterV #(.BIT_WIDTH(n)) ac_reg(.clk(clk), .w(recv_rdy), .d(ac), .q(ac_imm), .reset());
	RegisterV #(.BIT_WIDTH(n)) ar_reg(.clk(clk), .w(recv_rdy), .d(ar), .q(ar_imm), .reset());


	assign cr = ar_imm + tr;
	assign cc = ac_imm + tc;
	assign dr = ar_imm - tr;
	assign dc = ac_imm - tc;
endmodule
`endif

`line 4 "./FFT_StageVRTL.v" 0



module FFT_StageVRTL
    #(
        BIT_WIDTH  = 32,
        DECIMAL_PT = 16,
        N_SAMPLES  = 8,
        STAGE_FFT  = 0
    )
    (
        input  logic [BIT_WIDTH - 1:0] recv_msg_real [N_SAMPLES - 1:0],
        input  logic [BIT_WIDTH - 1:0] recv_msg_imag [N_SAMPLES - 1:0],
        input  logic                   recv_val                  ,
        output logic                   recv_rdy                  ,

        output logic [BIT_WIDTH - 1:0] send_msg_real [N_SAMPLES - 1:0],
        output logic [BIT_WIDTH - 1:0] send_msg_imag [N_SAMPLES - 1:0],
        output logic                   send_val                  ,
        input  logic                   send_rdy                  ,

        input  logic [BIT_WIDTH - 1:0] sine_wave_out [0:N_SAMPLES - 1],

        input  logic                   reset                     ,
        input  logic                   clk
    );


    logic                   val_in         [N_SAMPLES - 1:0];
    logic                   rdy_in         [N_SAMPLES - 1:0];

    logic                   val_out        [N_SAMPLES - 1:0];
    logic                   rdy_out        [N_SAMPLES - 1:0];

    logic [N_SAMPLES - 1:0] imm;
    always @(*) begin
        int i;
        for(i = 0; i < N_SAMPLES; i++) begin

            
            val_in[i] = recv_val;
            imm[i] = rdy_in[i];
        end
        recv_rdy = &imm;
    end

    
    logic [BIT_WIDTH - 1:0] butterfly_in_real       [N_SAMPLES - 1:0];
    logic [BIT_WIDTH - 1:0] butterfly_out_real      [N_SAMPLES - 1:0];
    logic [BIT_WIDTH - 1:0] butterfly_in_imaginary  [N_SAMPLES - 1:0];
    logic [BIT_WIDTH - 1:0] butterfly_out_imaginary [N_SAMPLES - 1:0];

    logic                   val_interior_in         [N_SAMPLES - 1:0];
    logic                   rdy_interior_in         [N_SAMPLES - 1:0];
    logic                   val_interior_out        [N_SAMPLES - 1:0];
    logic                   rdy_interior_out        [N_SAMPLES - 1:0];

    logic [BIT_WIDTH - 1:0] twiddle_real            [N_SAMPLES/2 - 1:0];
    logic [BIT_WIDTH - 1:0] twiddle_imaginary       [N_SAMPLES/2 - 1:0];

    logic                   val_interior_mini       [N_SAMPLES/2 - 1:0];
    logic                   rdy_interior_mini       [N_SAMPLES/2 - 1:0];

    CombinationalFFTCrossbarVRTl #(.BIT_WIDTH(BIT_WIDTH),                          .SIZE_FFT(N_SAMPLES),                                     .STAGE_FFT(STAGE_FFT),              .FRONT(1)) xbar_in_1
                                  (.recv_real(recv_msg_real),                   .recv_imaginary(recv_msg_imag),                        .recv_val(val_in),       .recv_rdy(rdy_in), 
                                   .send_real(butterfly_in_real[N_SAMPLES - 1:0]), .send_imaginary(butterfly_in_imaginary[N_SAMPLES - 1:0]), .send_val(val_interior_in), .send_rdy(rdy_interior_in));

    generate
        genvar b;    
        for( b = 0; b < N_SAMPLES/2; b++) begin
			localparam IX =
				(b%(2**STAGE_FFT))*(N_SAMPLES/(2*(2**STAGE_FFT)));

			localparam MMC =
				((IX==0)? 1 : (IX==N_SAMPLES/2)? 2 : (IX==N_SAMPLES/4)? 3 : (IX==3*N_SAMPLES/4)? 4 : 0);

            ButterflyVRTL #( .n(BIT_WIDTH), .d(DECIMAL_PT) ,
			.mult(MMC)) bfu_in ( .ar(butterfly_in_real[ b * 2     ]), .ac(butterfly_in_imaginary[ b * 2     ]), 
                                                                      .br(butterfly_in_real[(b * 2) + 1]), .bc(butterfly_in_imaginary[(b * 2) + 1]), 
                                                                      .wr(twiddle_real     [b]),           .wc(twiddle_imaginary     [b]          ),
                                                                      .recv_val(val_interior_in[b * 2] && val_interior_in[(b * 2) + 1]), .recv_rdy(rdy_interior_mini[b]),
                                                                      .cr(butterfly_out_real[b * 2]),       .cc(butterfly_out_imaginary[b * 2]), 
                                                                      .dr(butterfly_out_real[(b * 2) + 1]), .dc(butterfly_out_imaginary[(b * 2) + 1]),
                                                                      .send_rdy(rdy_interior_out[b * 2] && rdy_interior_out[(b * 2) + 1]), .send_val(val_interior_mini[b]),
                                                                      .reset(reset), .clk(clk));


        

        assign val_interior_out[(b * 2) + 1] = val_interior_mini[b]; //
        assign val_interior_out[b * 2]       = val_interior_mini[b];

        assign rdy_interior_in [(b * 2) + 1] = rdy_interior_mini[b];
        assign rdy_interior_in [b * 2]       = rdy_interior_mini[b];
        end
    endgenerate

    

    CombinationalFFTCrossbarVRTl #(.BIT_WIDTH(BIT_WIDTH), .SIZE_FFT(N_SAMPLES), .STAGE_FFT(STAGE_FFT), .FRONT(0)) xbar_out_1
                                  (.recv_real(butterfly_out_real), .recv_imaginary(butterfly_out_imaginary), .recv_val(val_interior_out),   .recv_rdy(rdy_interior_out), 
                                       .send_real(send_msg_real),    .send_imaginary(send_msg_imag),      .send_val(val_out), .send_rdy(rdy_out));    

    TwiddleGeneratorVRTL #( .BIT_WIDTH(BIT_WIDTH), .DECIMAL_PT(DECIMAL_PT), .SIZE_FFT(N_SAMPLES), .STAGE_FFT(STAGE_FFT) ) twiddle_generator ( .sine_wave_in(sine_wave_out), .twiddle_real(twiddle_real), .twiddle_imaginary(twiddle_imaginary) );
    
    logic [N_SAMPLES - 1:0] imm2;
    always @(*) begin
        int i;
        for(i = 0; i < N_SAMPLES; i++) begin

            imm2[i] = val_out[i];
            rdy_out[i] = send_rdy;

        end
        send_val = &imm2;
    end
endmodule

`line 6 "FFTStageTestHarnessVRTL.v" 0

module FFTStageTestHarnessVRTL
    #(
        BIT_WIDTH  = 32,
        DECIMAL_PT = 16,
        N_SAMPLES  = 8,
        STAGE_FFT  = 0
    )
    (
        input  logic [2 * BIT_WIDTH * N_SAMPLES - 1:0] recv_msg,
        input  logic                   recv_val,
        output logic                   recv_rdy,

        output logic [2 * BIT_WIDTH * N_SAMPLES - 1:0] send_msg,
        output logic                   send_val,
        input  logic                   send_rdy,

        input  logic                   reset,
        input  logic                   clk
    );
    
    logic [BIT_WIDTH - 1:0] recv_msg_intermediate [2 * N_SAMPLES - 1:0];
    logic [BIT_WIDTH - 1:0] send_msg_intermediate [2 * N_SAMPLES - 1:0];

    logic [BIT_WIDTH - 1:0] sine_wave_out [0:N_SAMPLES - 1];

    always @(*) begin
        int i;
        for(i = 0; i < 2 * N_SAMPLES; i = i + 1) begin

            send_msg   [BIT_WIDTH * i +: BIT_WIDTH] = send_msg_intermediate [i][BIT_WIDTH - 1:0];
            recv_msg_intermediate [i][BIT_WIDTH - 1:0]        = recv_msg[BIT_WIDTH * i +: BIT_WIDTH];
        end
    end

    generate 
        if(N_SAMPLES == 16) begin
            SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_16VRTL SineWave (.sine_wave_out(sine_wave_out));
        end else if(N_SAMPLES == 8) begin
            SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_8VRTL SineWave (.sine_wave_out(sine_wave_out));
        end else if(N_SAMPLES == 4) begin
            SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_4VRTL SineWave (.sine_wave_out(sine_wave_out));
        end else if(N_SAMPLES == 2) begin
            SineWave__BIT_WIDTH_32__DECIMAL_POINT_16__SIZE_FFT_2VRTL SineWave (.sine_wave_out(sine_wave_out));
        end
    endgenerate

    FFT_StageVRTL #( .BIT_WIDTH(BIT_WIDTH), .DECIMAL_PT(DECIMAL_PT), .N_SAMPLES(N_SAMPLES), .STAGE_FFT(STAGE_FFT)) fft_stage
    (
        .recv_msg_real(recv_msg_intermediate[2 * N_SAMPLES - 1: N_SAMPLES]),
        .recv_msg_imag(recv_msg_intermediate[    N_SAMPLES - 1: 0        ]),
        .recv_val(recv_val),
        .recv_rdy(recv_rdy),

        .send_msg_real(send_msg_intermediate[2 * N_SAMPLES - 1: N_SAMPLES]),
        .send_msg_imag(send_msg_intermediate[    N_SAMPLES - 1: 0        ]),
        .send_val(send_val),
        .send_rdy(send_rdy),

        .sine_wave_out(sine_wave_out),

        .reset(reset),
        .clk(clk)
    );

endmodule

`endif /* FFTSTAGETESTHARNESSVRTL */
//-----------------------------------------------------------
// Wrapper of placeholder FFTStageTestHarnessVRTL__c0423b316f90c825
//-----------------------------------------------------------

`ifndef FFTSTAGETESTHARNESSVRTL__C0423B316F90C825
`define FFTSTAGETESTHARNESSVRTL__C0423B316F90C825

module CombinationalFFT_stage
(
  input logic [1-1:0] clk ,
  input logic [1-1:0] reset ,
  input logic [256-1:0] recv_msg ,
  output logic [1-1:0] recv_rdy ,
  input logic [1-1:0] recv_val ,
  output logic [256-1:0] send_msg ,
  input logic [1-1:0] send_rdy ,
  output logic [1-1:0] send_val 
);
  FFTStageTestHarnessVRTL
  #(
    .BIT_WIDTH( 32 ),
    .DECIMAL_PT( 16 ),
    .N_SAMPLES( 4 ),
    .STAGE_FFT( 1 )
  ) v
  (
    .clk( clk ),
    .reset( reset ),
    .recv_msg( recv_msg ),
    .recv_rdy( recv_rdy ),
    .recv_val( recv_val ),
    .send_msg( send_msg ),
    .send_rdy( send_rdy ),
    .send_val( send_val )
  );
endmodule

`endif /* FFTSTAGETESTHARNESSVRTL__C0423B316F90C825 */

